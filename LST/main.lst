C51 COMPILER V9.57.0.0   MAIN                                                              05/08/2018 08:19:57 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\EXE\main.obj
COMPILER INVOKED BY: G:\Program Files\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\LST\main.lst) TABS(2) OBJECT(.\EXE\main.obj)

line level    source

   1          #include <REG51.H>
   2          
   3          // Diody
   4          xdata unsigned char PTWY _at_ 0x8008;
   5          
   6          
   7          // WYSW segmentowy LED
   8          xdata unsigned char WLED _at_ 0x8018;
   9          unsigned char WYSW[4];
  10          code const unsigned char cyferki[17] = {  0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77
             -, 0x79, 0x0F, 0x1F, 0x0E, 0X71, 0x00};
  11          char q, z;
  12          
  13          // Klawiatura numeryczna
  14          unsigned char kol_val = 0, wiersz_val = 0, key_val =0, key_int = 0;
  15          int Pr = 0, liczba, locked;
  16          unsigned char freq[4];
  17          
  18          // PWM_Pin
  19          sbit PWM_Pin = 0x96;
  20          
  21          // Deklaracje
  22          void Init(void);
  23          int lenght(int x);
  24          
  25          // Zmienne PWM
  26          unsigned char PWM = 0;    //  0 (0%) - 255 (100%)
  27          unsigned int temp = 0;    // Dla przerwania
  28          
  29          int PWMfreq = 1;  // Czestotliwosc
  30          
  31          // LCD
  32          xdata unsigned char CTRLW _at_ 0x8010;
  33          xdata unsigned char DATW _at_ 0x8011;
  34          xdata unsigned char CTRLR _at_ 0x8012;
  35          xdata unsigned char DATR _at_ 0x8013;
  36          
  37          
  38          // ADC
  39          xdata unsigned char PTAC0 _at_ 0x8005;
  40          unsigned char POT0(void);
  41          
  42          
  43          unsigned int cycles = 0;
  44          unsigned int cyfra = 0;
  45           unsigned int b;
  46           int h = 0;
  47          void BUSYLCD(void)
  48          {
  49   1       while (CTRLR&0x80);
  50   1      }
  51          
  52          void main (void)
  53          {
C51 COMPILER V9.57.0.0   MAIN                                                              05/08/2018 08:19:57 PAGE 2   

  54   1      
  55   1        Init();              // Inicjalizacja         
  56   1        
  57   1      
  58   1      
  59   1        // LCD INIT 
  60   1        
  61   1      
  62   1       for(b=0;b<15000;b++);
  63   1       CTRLW=0x38;
  64   1       for(b=0;b<4200;b++);
  65   1       CTRLW=0x38;
  66   1       for(b=0;b<120;b++);
  67   1       CTRLW=0x38;
  68   1       BUSYLCD();
  69   1       CTRLW=0x38;
  70   1       BUSYLCD();
  71   1       CTRLW=0x0c;
  72   1       BUSYLCD();
  73   1       CTRLW=0x02;
  74   1       CTRLW=0x01;
  75   1       BUSYLCD();
  76   1       CTRLW=0x06;
  77   1       BUSYLCD();
  78   1       CTRLW=0x80;
  79   1       BUSYLCD();
  80   1      
  81   1      
  82   1       
  83   1       while(1)
  84   1       {
  85   2        PWMfreq = 250;
  86   2         
  87   2        b=POT0();
  88   2        PWM = b; 
  89   2        DATW = 'W';
  90   2        BUSYLCD();
  91   2        DATW = 'Y';
  92   2        BUSYLCD();
  93   2        DATW = 'P';
  94   2        BUSYLCD();
  95   2        DATW = ' ';
  96   2        BUSYLCD();
  97   2        b=(b*100)/255;
  98   2        DATW=b/100+'0';
  99   2        BUSYLCD();
 100   2        DATW=(b/10)%10+'0';
 101   2        BUSYLCD();
 102   2        DATW=b%10+'0';
 103   2        BUSYLCD();
 104   2        CTRLW=0x80; 
 105   2        BUSYLCD();
 106   2        
 107   2        
 108   2        // Wypelnienie WLED
 109   2        for(z=0;z<4;z++){WYSW[z] = 16;};
 110   2      
 111   2        liczba = (POT0()*100)/255;
 112   2        if(lenght(liczba)==2){
 113   3        WYSW[1] = liczba%10;
 114   3        WYSW[2] = liczba/10;
 115   3        }else if(lenght(liczba)==1){
C51 COMPILER V9.57.0.0   MAIN                                                              05/08/2018 08:19:57 PAGE 3   

 116   3        WYSW[2] = liczba%10;
 117   3        }else if(lenght(liczba)==3){
 118   3        WYSW[0] = liczba%10;
 119   3        WYSW[1] = (liczba/10)%10;
 120   3        WYSW[2] = liczba/100;
 121   3        }
 122   2        
 123   2      
 124   2        
 125   2        DATW = 'P';
 126   2        BUSYLCD();
 127   2        DATW = 'W';
 128   2        BUSYLCD();
 129   2        DATW = 'M';
 130   2        BUSYLCD();
 131   2        DATW = ' ';
 132   2        BUSYLCD();
 133   2        DATW = 'f';
 134   2        BUSYLCD();
 135   2        DATW = ' ';
 136   2        BUSYLCD();
 137   2        DATW=freq[0]+'0';
 138   2        BUSYLCD();
 139   2        DATW=freq[1]+'0';
 140   2        BUSYLCD();
 141   2        DATW=freq[2]+'0';
 142   2        BUSYLCD();
 143   2        DATW=freq[3]+'0';
 144   2        BUSYLCD();
 145   2        DATW=' ';
 146   2        BUSYLCD();
 147   2        DATW='H';
 148   2        BUSYLCD();
 149   2        DATW='z';
 150   2        BUSYLCD();
 151   2        CTRLW=0xC0; 
 152   2        BUSYLCD();
 153   2        
 154   2        
 155   2       
 156   2        
 157   2       }
 158   1      }
 159          
 160          
 161          // Timer0 init
 162          void InitTimers(void)
 163          {
 164   1      TMOD = 0x11;    // Zalaczanie przerwania 1 i 2
 165   1      TCON = 0x50;
 166   1      TH0 = 0x00;      // First time value
 167   1      TL0 = 0x00; 
 168   1      TH1 = 0x00;      // First time value
 169   1      TL1 = 0x00; 
 170   1      ET0 = 1;         // Enable przerwan
 171   1      EA  = 2;        
 172   1      TR0 = 1; 
 173   1      TR1 = 1;  
 174   1      ET1 = 1;
 175   1      }
 176          
 177          
C51 COMPILER V9.57.0.0   MAIN                                                              05/08/2018 08:19:57 PAGE 4   

 178          // Odczyt z ADCka POT0
 179          unsigned char POT0(void)
 180          {
 181   1       unsigned char a=0;
 182   1       PTAC0=0;
 183   1       for(a=0;a<120;a++);
 184   1       return PTAC0;
 185   1      }
 186          
 187          
 188          
 189          // Init PWM & Timerów
 190          void Init(void)
 191          {
 192   1      PWM = 0;         // Wypelnienie 0
 193   1      InitTimers();    // Uruchom timer przerwan
 194   1      
 195   1      }
 196          
 197          
 198          int lenght(int x) {
 199   1          if(x>=1000){
 200   2            return 4;
 201   2          }else if(x>=100){
 202   2            return 3;
 203   2          }else if(x>=10){
 204   2            return 2;
 205   2          }else{
 206   2          return 1;
 207   2          }
 208   1      }
 209          
 210          
 211          
 212          
 213          
 214          
 215          // Timer0
 216          void Timer0 (void) interrupt 1  
 217          {
 218   1      TR0 = 0;    // Stop Timer 0
 219   1       
 220   1      TH0 = (unsigned char)(-5000 >> 8);
 221   1      TL0 = (unsigned char)(-5000 & 0x00ff);
 222   1        
 223   1      if(PWM_Pin) // Na stan wysoki
 224   1      {
 225   2      PWM_Pin = 0;
 226   2      temp = (255-PWM)*PWMfreq;
 227   2      TH0  = 0xFF - (temp>>8)&0xFF;
 228   2      TL0  = 0xFF - temp&0xFF;
 229   2      }
 230   1      else       // Na stan niski
 231   1      {
 232   2      PWM_Pin = 1;
 233   2      temp = PWM*PWMfreq;
 234   2      TH0  = 0xFF - (temp>>8)&0xFF;
 235   2      TL0  = 0xFF - temp&0xFF;
 236   2      }
 237   1       
 238   1      TF0 = 0;     // Czyszczenie flagi przerwania
 239   1      TR0 = 1;     // Start Timera
C51 COMPILER V9.57.0.0   MAIN                                                              05/08/2018 08:19:57 PAGE 5   

 240   1      }
 241          
 242          
 243          void Timer1 (void) interrupt 3  
 244          {
 245   1      TR1 = 0;    // Stop Timer 0
 246   1       
 247   1      TH1 = (unsigned char)(-2500 >> 16);
 248   1      TL1 = (unsigned char)(-2500 & 0xffff);
 249   1        
 250   1          key_val=++key_val&3; 
 251   1          P1=(P1&0xc0)|0x3c|key_val;
 252   1          //PSEG=cyferki[Pr];
 253   1        
 254   1            WLED = cyferki[WYSW[q]];
 255   1          if(++q>3){q=0;} 
 256   1        
 257   1        for(wiersz_val = 0;wiersz_val<4; wiersz_val++)
 258   1          {
 259   2              if(!(P1&(4<<wiersz_val)))
 260   2            {
 261   3              key_val = key_val + wiersz_val*4;
 262   3              Pr = key_val;
 263   3              PTWY = Pr;
 264   3            
 265   3              // Super kod filtrujacy klawisze
 266   3              locked = Pr;
 267   3              if(locked==999){
 268   4              }else{
 269   4                  if(key_int>4){
 270   5              key_int = 0;
 271   5              }
 272   4              freq[key_int]= Pr;
 273   4              key_int = key_int+1;
 274   4              locked = 999;
 275   4              }
 276   3            
 277   3              
 278   3          
 279   3              
 280   3            }
 281   2      
 282   2          }
 283   1        
 284   1        
 285   1        
 286   1       
 287   1      TF1 = 0;     // Czyszczenie flagi przerwania
 288   1      TR1 = 1;     // Start Timera
 289   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    904    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
